## Ссылочки на более профильные источники

Записки kiriharu https://notes.kiriha.ru
Записки yakimka https://github.com/yakimka/python_interview_questions/blob/master/questions.md
Intermediate Python https://pavel-karateev.gitbook.io
Easyoffer https://easyoffer.ru/rating/python_developer

## Стандартные вопросы

#### Шо такое этот ваш Python?

Интерпретируемый язык программирования динамически типизированный со строгой валидацией данных

#### Какие бывают типы данных?

Изменяемые (mutable)
```python
list, dict, set, bytearray
```
- Списки
- Словари
- Множества
- Байтовые массивы

Не изменяемые (immutable)
```python
int, float, complex, long, str, bool, range, NoneType, frozenset, bytes, tuple
```
- Числа
- Строки
- Булево выражение
- Диапазон
- NoneType
- frozenset
- Байты
- Кортежи – если содержат изменяемые, то изменяемый

#### В чем основные различия версий python 2.х от 3.х

- Любая попытка комбинировать текст и данные в Python 3.0 поднимает `TypeError`, в то время как смешивание Unicode и 8-битных строк в Python 2.x, это работает, если 8-битная строка содержит только 7-битные (ASCII) символы, но вызывает `UnicodeDecodeError`, если содержит не-ASCII символы.
- Кодировка исходного кода по умолчанию в Python 3 - UTF-8
- Оператор `print` был заменён функцией `print()`
- Функция `raw_input` была заменена `input`, а функция `input` из Pytnon 2 удалена
- Некоторые хорошо известные методы не возвращают списки в Python 3 (`dict.keys()`, `dict.items()`, `dict.values()`, `map()`, `filter()`, `zip()` и `range()` вместо `xrange()` возвращают итератор).
- `repr()` от длинного целого числа не включает более завершающий символ `L`. А также больше не экранирует символы, не входящие в набор ASCII
- `long` переименован в `int`.
- Выражение вида `1/2` возвращает `float`. Используйте `1//2` для отсечения дробной части.
- Операторы сравнения (`<`, `<=`, `>=`, `>`) поднимают исключение `TypeError`, когда операнды не упорядочиваемы. Таким образом, выражения типа `1 < ''`, 0` > None` или `len <= len` более не разрешены, и, например, `None < None` поднимает `TypeError`, а не возвращает `False`.
- В Python 2 отсутствует синтаксис аннотирования типов
- В Python 3 добавлен оператор `nonlocal`, который позволяет задавать переменную во внешней (но не глобальной) области видимости.
- Новый синтаксис для метаклассов. Вместо: `class C: __metaclass__ = M` используется `class C(metaclass=M)`
- Другие изменения: https://pythonworld.ru/osnovy/python2-vs-python3-razlichiya-sintaksisa.html

#### Что такое контекстный менеджер

Менеджер контекста позволяет выделять и освобождать ресурсы строго по необходимости. В Python за это отвечает блок с оператором `with`. Он имеет следующую конструкцию:

```csharp
[async] with <функция> as <переменная>:
    ...
```

Контекстный менеджер должен иметь следующие методы:
1. Если он синхронный - `__enter__` и `__exit__`
2. Если асинхронный - `__aenter__` и `__aexit__`

#### Что такое тернарный оператор? Как записывается?

Тернарный (условный) оператор — это однострочный оператор if/else.

```python
True if condition else False
```


#### Чем отличаются операторы == и is

Оператор `==` проверяет, одинаковые ли значения у переменных. Реализуется с помощью метода `__eq__`, а значит есть возможность его переопределить.

Оператор `is` проверяет, указывают ли переменные на один и тот же объект.

```python
a = [1, 2]
b = [1, 2]
print(a == b)  # True
print(a is b)  # False
```


#### Что делает конструкция for/else?

Блок `else`выполняется, если цикл не встретил `break`оператора.

#### Как в Python передаются аргументы в функцию? (изменяемые и не изменяемые)

При передаче аргумента в функцию в Python не используется ни модель передачи по значению, ни модель передачи по ссылке.

**В Python всё является объектом**. Каждый объект имеет следующие характеристики:

- идентификатор - каждый объект обладает уникальными номером, который можно узнать с помощью функции `id()`;
- тип - каждый тип обладает своими операциями, которые можно применять, который можно узнать с помощью функции `type()`;
- содержимое самого объекта.

Объекты в Python могут быть изменяемыми (mutable) или неизменяемыми (immutable). Это свойство полностью зависит от типа объекта. Иными словами, не/изменяемость является характеристикой типа, а не конкретных объектов.
Тип является изменяемым, если содержимое объекта может быть изменено без изменений его идентификатора и типа.
Вызывая различные методы, призванные как-то модифицировать состояние, объекты с неизменяемым типом что-то возвращают, в отличие от изменяемых.

Название переменной — это не то же самое, что и сам объект, это просто метка, которая связана с объектом с определёнными идентификатором, типом и содержимым. Это называется механизмом связывания.

Чтобы проверить являются ли два объекта одной сущностью, используется оператор `is`. Объекты, которые имеют тот же тип и содержимое, но не `id`, не являются одним объектом.

**В Python используется модель *передачи через присваивание (pass-by-assignment)***

При вызове функции каждый параметр связывается с соответствующим объектом, указанным в сигнатуре функции. Таким образом, если в функцию передаётся неизменяемый параметр - у функции нет возможности хоть как-то его изменить, если изменяемый - может быть изменен, точнее его содержимое.

Каждый раз, когда используется присваивание, то создается новый объект, хоть и имеющий то же самое имя.

#### Что такое args и kwargs? Чем представлены?

Выражения `*args` и `**kwargs` объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами `args` и `kwargs` (без звездочек).

`args` – это кортеж, который накапливает позиционные аргументы. `kwargs` – словарь именованных аргументов, где ключ – имя параметра, значение – значение параметра.

Если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`.

Если в определении функции нет специальных символов `/` и `*`, то аргументы могут быть переданы функции по позиции или по ключевому слову.
```
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |                |              |
        |         позиционные или       |
        |         по ключу               - только по ключевому слову
        |
         -- только по позиции
```

#### Что такое аннотации типов? Зачем нужны? Когда выполняются?

Для улучшения читаемости кода и его поддержки, есть возможность определять аннотации типов.

В простейшем случае аннотация содержит непосредственно ожидаемый тип. Аннотации для переменных пишут через двоеточие после идентификатора. После этого может идти инициализация значения.

Параметры функции аннотируются также, как переменные, а возвращаемое значение указывается после стрелки `->` и до завершающего двоеточия.

Если же функция никогда не возвращает управление (например, как `sys.exit`), следует использовать аннотацию `NoReturn`.

Для полей класса аннотации должны быть указаны явно при определении класса.

Пример:

```python
from typing import Any, NoReturn

price: int = 5

def func(param: Any) -> NoReturn:
    while True:
        pass

class Book:
    title: str
    author: str
```

Аннотации никак не влияют на ход выполнения программы и не защищают от неправильных типов. Аннотации были введены с версии Python 3.5

#### Что такое lambda функция? Где можно применить?

Это анонимная функция, записывается в одну строку. Обычно используется в качестве callable аргумента в функциях `map`, `filter`, `list.sort` или как внешняя функция с отложенным выполнением:
```python
print_hello = lambda: print("Hello!")
print_hello()  # Hello!
```

#### Как обрабатываются исключения в Python?

```python
try:
    print('Я уверен, исключений не будет!')
except Exception:
    print('Исключение')
else:
    # Любой код, который должен быть исполнен, если исключение в блоке
    # try не было вызвано, но для которого не должна проводиться
    # обработка исключений
    print('Я буду исполнен, если в try не будет исключений.'
    'Мои исключения не будут обрабатываться.')
finally:
    print('Я буду исполнен в любом случае!')
```

Дерево исключений в Python3:
```java
BaseExeption
├─╴GeneratorExit
├─╴SystemExit
├─╴KeyboardInterrupt
└─╴Exeption
   ├─╴Error
   ├─╴TypeError
   ├─╴ImportError
   │  └─╴ZipImportError
   ├─╴ArithmeticError
   │  ├─╴FloatingPointError
   │  ├─╴OverflowError
   │  └─╴ZeroDivisionError
   ├─╴EOFError
   ├─╴AttributeError
   ├─╴SyntaxError
   │  ├─╴IndentationError
   │  └─╴TabError
   ├─╴RunTimeError
   │  ├─╴NotImplementationError
   │  └─╴DeadlockError
   ├─╴NameError
   │  └─╴UnboundLocalError
   ├─╴SystemError
   │  └─╴CodecRegistryError
   ├─╴LookupError
   │  ├─╴IndexError
   │  ├─╴KeyError
   │  └─╴CodecRegistryError
   ├─╴ValueError
   │  ├─╴UnicodeError
   │  │  ├─╴UnicodeEncodeError
   │  │  ├─╴UnicodeDecodeError
   │  │  └─╴UnicodeTranslateError
   │  └─╴UnsupportedOperation
   ├─╴Warning
   │  ├─╴UserWarning
   │  ├─╴DeprecationWarning
   │  ├─╴PendingDeprecationWarning
   │  ├─╴RunTimeWarning
   │  ├─╴FutureWarning
   │  ├─╴ImportWarning
   │  ├─╴UnicodeWarning
   │  ├─╴BytesWarning
   │  └─╴ResourseWarning
   ├─╴AssertationError
   ├─╴MemoryError
   ├─╴BufferError
   ├─╴ReferenceError
   ├─╴StopIteration
   └─╴OSError
      ├─╴ConnectionError
      │  ├─╴BrokenPipeError
      │  ├─╴ConnectionAbortedError
      │  ├─╴ConnectionRefusedError
      │  └─╴ConnectionResetError
      ├─╴TimeoutError
      ├─╴ItimerError
      ├─╴PermissionError
      ├─╴BlockingIOError
      ├─╴ProcessLookupError
      ├─╴ChildProcessError
      ├─╴IsADirectoryError
      ├─╴FileExistsError
      ├─╴FileNotFoundError
      ├─╴NotADirectoryError
      ├─╴UnsupportedOperation
      └─╴InerruptedError
```

#### Что такое хэш функция? Для чего?

Функция `hash()` возвращает хеш-значение объекта, если оно есть. Хэш-значения являются целыми числами. Они используются например для быстрого сравнения ключей словаря во время поиска в словаре.

Равные числовые значения имеют одинаковое значение хеш-функции, даже если они имеют разные типы, как в случае с `1` и `1.0`.

Пользовательские типы могут переопределять метод `__hash__()`, результат которого будет использован при вызове функции `hash()`. Однако, следует помнить, что функция `hash()` обрезает значение в соответствии с битностью хоста.

#### Что может быть ключом в dict?

Ключом в словаре может быть любой объект, который можно хэшировать (примитивные типы + классы в которых реализуется `__hash__()`)
- из стандартных: `int`, `string`, `frozenset`, `tuple`
- не может: `list`, `set`, `dict`

#### Что такое map? filter? reduse? Чем отличаются?

Функция `map()` применяет функцию ко всем элементам списка.
По сути это генератор, принимает 2 аргумента: calalble и список, возвращает новый генератор, в котором все значения списка мутированы функцией.

Функция `filter()` работает как `map()`, но возвращает список элементов, для которых заданная функция возвращает `True`.

Функция `reduse()` сворачивает список, применяя полученную в качестве аргумента функцию по очереди к последовательным парам элементов. Например, если мы хотим посчитать произведение всех элементов в списке чисел.

```python
from functools import reduce

product = reduce((lambda x, y: x * y), [1, 2, 3, 4])  # product = 24
```

#### Что такое глубокая и поверхностная копия? Зачем нужны? Как их сделать?

**Поверхностная копия** создаёт новый объект и затем в новый объект вставляются ссылки на объекты, которые были у копируемого объекта.

Поверхностную копию можно сделать при помощи `copy.copy()`. Переопределить поведение функции можно при помощи магического метода `__copy__`.

Если мы попробуем скопировать иммутабельный объект, то получим ссылку на него.

**Глубокая копия** создает новый объект, а затем рекурсивно пытается сделать копии внутренних объектов.

Глубокую копию можно сделать при помощи `copy.deepcopy()`. Переопределить поведение функции можно при помощи магического метода `__deepcopy__`. Таким образом при копировании можно не копировать некоторые объекты, а оставлять ссылку на них.

Проблемы при создании глубокой копии:
- Рекурсивные объекты (которые содержат ссылки сами на себя) могут стать причиной рекурсивного цикла.
- Не всё можно скопировать.
- Иногда могут копироваться данные, которые должны быть разделяемы между копиями

`deepcopy` может вторым аргументом принимать словарь `memo`, который хранит уже скопированные объекты во время текущего прохода копирования. Это помогает при копировании рекурсивных объектов.

#### Что такое виртуальное окружение? Зачем оно нужно? Какие инструменты для этого используются?

Виртуальное окружение (virtualenv) — это инструмент для создания отдельного пространства для проекта с его зависимостями и библиотеками в директории проекта.

```
pip install virtualenv
```

Две основные команды:

```bash
virtualenv myproject
source myproject/bin/activate
```

Первая создаст новое изолированное окружение в папке `myproject`, а вторая активирует это окружение.

Так же есть и другие инструменты, позволяющие организовать виртуальное окружение, например, pipenv, который позволяет лучше организовать работу с requirements.txt с помощью `pipenv lock`.

```bash
pip install pipenv
```

#### Что такое Poetry? Зачем нужен?

Poetry - это инструмент для управления зависимостями в Python проектах (аналог встроенного pip)

```bash
pip install poetry
```

Более подробней: https://habr.com/ru/articles/593529/

#### Что такое декораторы? Зачем нужны? Как реализовать простой декоратор и декоратор с пробросом аргумента?

Декоратором называется функция, которая принимает функцию с таким же именем, как у исходной, но с расширенной функциональностью.

Декораторы часто используются во фреймворках, чтобы упростить интеграцию пользовательских функций с фреймворком.

Декорировать можно как функции, так и методы. Кроме того, Python поддерживает декораторы классов: функции, которые принимают класс в качестве аргумента и возвращают новый класс с таким же именем, как у исходного, но с дополненной функциональностью.

Пример простейшего декоратора:
```python
def decorator(func):  
    def wrapper():  
        print(f"Запускаю функцию {func.__name__}()")  
        result = func()  
        print(f"Функция {func.__name__} вернула значение \"{result}\"")  
        return result  
    return wrapper  

@decorator  
def say():  
    return 'я твой отец'  

print(say())
print(decorator(lambda: 'я твой отец')())  # Вызов декоратора без @
# Запускаю функцию <lambda>|say()  
# Функция <lambda>|say вернула значение "я твой отец"  
# я твой отец
```

Пример декоратора функции с аргументами
```python
def decorator(func):  
    def wrapper(*args):  # Приём аргументов функции
        print(f"Запускаю функцию {func.__name__}{args}")  
        result = func(*args)  # Передача их самой функции
        print(f"Функция {func.__name__} вернула значение \"{result}\"")  
        return result  
    return wrapper  

@decorator  
def say(*args):  
    return ' '.join(args)  

print(say('я', 'твой', 'отец'))
print(decorator(lambda *args: ' '.join(args))('я', 'твой', 'отец'))
# Запускаю функцию <lambda>|say('я', 'твой', 'отец')  
# Функция <lambda>|say вернула значение "я твой отец"  
# я твой отец
```

Пример декоратора с аргументами функции с аргументами
```python
def decorator(greeting="", farewell=""):  # Приём аргуметов декоратора
    def inner(func):  # Дополнительная обёртка
        def wrapper(*args):  
            print(f"Запускаю функцию {func.__name__}{args}")  
            result = func(*args)  
            print(f"Функция {func.__name__} вернула значение \"{result}\"")  
            return ' '.join((greeting, result, farewell))  # Использование
        return wrapper  
    return inner  

@decorator(greeting='Привет!', farewell='Пока.')  # Передача аргументов декоратора
def say(*args):  
    return ' '.join(args) + '.'  

print(say('Я', 'твой', 'отец'))
print(decorator('Привет!', 'Пока.')(lambda *args: ' '.join(args) + '.')('Я', 'твой', 'отец'))
# Запускаю функцию <lambda>|say('Я', 'твой', 'отец')  
# Функция <lambda>|say вернула значение "Я твой отец."  
# Привет! Я твой отец. Пока.
```

Так же есть возможность создания декоратора с использование функции `functools.wraps`. `@wraps` принимает на вход функцию для декорирования и добавляет функциональность копирования имени, строки документации, списка аргументов и т.д. Это открывает доступ к свойствам декорируемой функции из декоратора.

Декораторы так же можно делать из классов, а не из вложенных функций.

```python
from functools import wraps  

class Decorator:  
    def __init__(self, greeting="", farewell="", *args):  
        self.greeting = greeting  
        self.farewell = farewell  
        super(Decorator, self).__init__(*args)  
  
    def __call__(self, func):  
        @wraps(func)  
        def wrapper(*args):  
            print(f"Запускаю функцию {func.__name__}{args}")  
            result = func(*args)  
            print(f"Функция {func.__name__} вернула значение \"{result}\"")  
            return ' '.join((self.greeting, result, self.farewell))  
        return wrapper  

@Decorator(greeting='Привет!', farewell='Пока.')  
def say(*args):  
    return ' '.join(args) + '.'  

print(say('Я', 'твой', 'отец'))  
print(Decorator('Привет!', 'Пока.')(lambda *args: ' '.join(args) + '.')('Я', 'твой', 'отец'))  
# Запускаю функцию <lambda>|say('Я', 'твой', 'отец')  
# Функция <lambda>|say вернула значение "Я твой отец."  
# Привет! Я твой отец. Пока.
```

#### Что делают декораторы @staticmethod, @classmethod и @property

`@classmethod` - декоратор, который позволяет вызвать метод, связанный с классом, а не экземпляром класса. Он имеет доступ ко всем атрибутам класса, может изменять состояние класса, что отражается на всех экземплярах класса. `@classmethod` принимает первым аргументом ссылку на класс, а не на экземпляр класса.

`@staticmethod` -  декоратор, который позволяет вызвать метод, который не имеет доступа ни к атрибутам экземпляра класса, ни к атрибутам класса. Он отделен от объектов класса и работает как обычная функция внутри класса. 

`@property` - декоратор, который позволяет превратить метод в свойство, чтобы предоставить управляемым атрибутам возможность и для чтения, и для записи.

```python
class Square:
    def __init__(self, side):
        self.__side = side

    @property
    def side(self):
        return self.__side

    @side.setter
    def side(self, value):
        self.__side = float(value)
```

#### Что такое списковое включение и генераторные выражения?

**Генераторное выражение** или **абстракция** - это конструкторы, позволяющие создавать последовательности из других последовательностей.

**Списковое включение** - разновидность генераторного выражения, где конечная последовательность – список.

Пример использования генераторных выражений: 
```python
data = (  
    ("key1", "value1"),  
    ("key2", "value2"),  
    ("key3", "value2"),  
)  
listcomp = [value for key, value in data if key != "key1"]  # Списковое включение
setcomp = {value for key, value in data if key != "key1"}  # Абстракция множества
dictcomp = {key: value for key, value in data if key != "key1"}  # Абстракция словаря
genexp = (value for key, value in data if key != "key1")  # Генераторное выражение
print(listcomp, setcomp, dictcomp, genexp, sep="\n")  
# ['value2', 'value2']  
# {'value2'}  
# {'key2': 'value2', 'key3': 'value2'}  
# <generator object <genexpr> at 0x000001BA616BF6B0>  
for item in genexp:  
    print(item, end=" ")  
# value2 value2
```

#### Что такое модификаторы доступа?

Есть три типа модификаторов доступов в Python ООП:

- публичный `public`
- приватный `__private`
- защищенный `_protected`

> в Python нету жесткой инкапсуляции, т.е. даже к приватному методу можно получить доступ снаружи класса. Инкапсуляция в Python это больше договорённость между разработчиками, чем жесткое сокрытие, как например в C++ или Java.

#### Какие способы задать переменную в глобальной области видимости?

Используя оператор `global` или замыкания.

#### Как работает память в python?
https://habr.com/ru/companies/domclick/articles/530804/


## Классы

#### Что такое класс?

Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт). С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

#### Что такое self в классах?

`self`  - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Он используется для доступа к атрибутам и методам экземпляра из методов класса.

#### Что такое __new__. И чем он отличается от __init__. В какой последовательности они выполняются

Основное различие между этими двумя методами состоит в том, что `__new__` обрабатывает создание объекта, а `__init__` обрабатывает его инициализацию.

`__new__` вызывается автоматически при вызове имени класса (при создании экземпляра), тогда как `__init__` вызывается каждый раз, когда экземпляр класса возвращается `__new__`, передавая возвращаемый экземпляр в `__init__` в качестве параметра `self`, поэтому даже если вы сохранили экземпляр где-нибудь глобально/статически и возвращали его каждый раз из `__new__`, для него все-равно будет каждый раз вызываться `__init__`.

Из вышесказанного вытекает что сначала вызывается `__new__`, а потом `__init__`

#### Зачем нужен метод super?

Метод `super` позволяет наследовать базовые классы (они же суперклассы или родительские классы) без необходимости явно ссылаться на базовый класс.

#### Как в python реализуются методы объекта, класса, статические методы? Чем они отличаются?

#### Чем отличается атрибут класса от атрибута объекта?

Атрибут **объекта** (переменная **экземпляра**) предназначен для данных уникальных для каждого объекта.

Атрибут **класса** (переменная **класса**) - для всех экземпляров класса.

#### Что такое абстрактный класс? Зачем он нужен? Как реализуется в python?

Абстрактный класс определяет общий интерфейс для набора подклассов. Он предоставляет общие атрибуты и методы для всех подклассов, чтобы уменьшить дублирование кода, также заставляя подклассы реализовывать абстрактные методы, чтобы избежать каких-то несоответствий.

Абстрактный класс используется для определения общего интерфейса для различных реализаций.

Абстрактный класс имеет некоторые особенности, а именно:
- Может содержать только абстрактные методов (объявление метода, без его подробной реализации).
- Предоставляет интерфейс для подклассов.
- Экземпляр абстрактного класса не создаётся.
- Производный подкласс должен реализовать абстрактные методы для создания конкретного класса, который соответствует интерфейсу, определенному абстрактным классом. Следовательно, экземпляр не может быть создан, пока не будут переопределены все его абстрактные методы.

Пример абстрактного класса в реализации паттерна абстрактной [фабрики](https://refactoring.guru/ru/design-patterns/abstract-factory/python/example)
```python
from abc import ABC, abstractmethod

class AbstractFactory(ABC):
    @abstractmethod
    def create_product_a(self) -> AbstractProductA:
        pass

    @abstractmethod
    def create_product_b(self) -> AbstractProductB:
        pass
```

#### Что такое миксины?

`Mixin` — это класс, предоставляющий реализации методов для повторного использования дочерними классами. Он представляет ограниченную форму множественного наследования и родительский класс, который просто даёт функциональные возможности подклассам, не содержит состояния и не предназначен для создания экземпляров.

Миксины используются, когда необходимо:
- предоставить множество дополнительных функций для класса;
- использовать определённую функцию во множестве разных классов.

#### Что такое метаклассы?

- [Метаклассы в Python: что это такое и с чем его едят](https://proglib.io/p/metaclasses-in-python/)
- [Метаклассы в Python](https://habr.com/ru/post/145835/)

Метакласс  - это «штука», которая создаёт классы.

Когда классы являются объектами для создания других объектах, метаклассы в этих самых классах создают эти самые объекты.

`type` это метакласс, который Python внутренне использует для создания всех классов.

Когда вы пишете:

```python
class Foo(Bar):
  pass
```

Питон делает следующее:

- Есть ли у класса Foo атрибут `__metaclass__`?
- Если да, создаёт в памяти объект-класс с именем Foo, используя то, что указано в `__metaclass__`.
- Если Питон не находит `__metaclass__`, он ищет `__metaclass__` в родительском классе Bar и попробует сделать то же самое.
- Если же `__metaclass__` не находится ни в одном из родителей, Питон будет искать `__metaclass__` на уровне модуля.
- И если он не может найти вообще ни одного `__metaclass__`, он использует `type` для создания объекта-класса.

Логика работы метакласса:
- перехватить создание класса
- изменить класс
- вернуть модифицированный

Основное применение метаклассов это создание API. Типичный пример — Django ORM. Она позволяет написать что-то в таком духе:

```python
class Person(models.Model):
  name = models.CharField(max_length=30)
  age = models.IntegerField()
```

Однако если вы выполните следующий код:

```python
guy = Person(name='bob', age='35')
print guy.age
```

вы получите не `IntegerField`, а `int`, причём значение может быть получено прямо из базы данных.

Это возможно, потому что `models.Model` определяет `__metaclass__`, который сотворит некую магию и превратит класс `Person`, который мы только что определили простым выражением в сложную привязку к базе данных.

Django делает что-то сложное выглядящее простым, выставляя наружу простой API и используя метаклассы, воссоздающие код из API и незаметно делающие всю работу.

#### Что такое MRO?

Method Resolution Order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей.

В классических классах поиск при наследовании по ссылкам на имена осуществляется в следующем порядке:

1. Сначала экземпляр
2. Затем его класс
3. Далее все суперклассы его класса с обходом сначала с глубину, а затем слева направо

Используется первое обнаруженное вхождение. Такой порядок называется DFLR (Обход в глубину и слева направо).


>В каком порядке Python будет искать методы в классе class A(B, C, D):, если все родительские классы унаследованы только от object?
>Правильный ответ: Сначала дочерний класс, потом родительские классы слева направо A, B, C, D

Отличие MRO3 от MRO2 в том, что с python3 все классы начали наследоваться от класса object.

#### Что такое NULL reference?

Плохая практика написания функции или метода, который может вернуть объект NoneType вместо исключения. Практика в Python не запрещена, но не поощряется. 

### ООП

#### Что такое ООП?

Это парадигма программирования, в которой основными концепциями являются понятия объектов и классов.

**Класс** — тип, описывающий устройство объектов

**Объект** — это экземпляр класса. Класс можно сравнить с чертежом, по которому создаются объекты.

#### Какие базовые принципы ООП?

- абстракция - в коде используем только те характеристика объекта, которые на важны в конкретном коде
- наследование - класс может строиться на основе другого класса, один класс дочерний, другой родительский, дочерний класс получает всё от родительского
- инкапсуляция - в класс должны поместить все атрибуты и методы, которые связаны общей идеей; должны быть приватные (`startswith("__")`) или протектные (`startswith("_")`) методы и атрибуты, из класса не должно ничего торчать лишнего
- полиморфизм - параметрический полиморфизм (утиная типизация) - функция, которая принимает некоторые аргументы и нужно чтобы этот аргумент умел все действия, которые мы у него используем. можем перегружать методы из дочернего класса, модифицируя их функционал 


## Коллекции

#### Какие коллекции есть?

#### namedtuple?

#### dataclass?

#### Какая сложность основных операций в коллекциях?


## Асинхронный код

#### Что такое итератор? Что такое итерируемый объект?

#### Что такое генератор? Как написать в python генератор?

#### Что такое корутина?

#### Что такое async await?

#### Какие есть типы асинхронного выполнения? Какие библиотеки работают с асинхронным выполнением кода? В чем между ними разница?


## Тестирование

#### Какие модули есть в python для тестирования?

#### unittest?

#### pytest?

#### Что такое mock? Зачем нужен?
